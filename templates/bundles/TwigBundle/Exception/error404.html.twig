{% extends 'base.html.twig' %}

{% block title %}404 - Page Introuvable | Niveau OP{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            background-color: #0A1C2B;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        .game-ui {
            position: absolute;
            color: #A3DFFF;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            text-shadow: 2px 2px #2A4859, 0 0 8px rgba(163, 223, 255, 0.5); /* Subtle glow */
            z-index: 1001;
            user-select: none;
        }
        .top-left { 
            top: 10px; 
            left: 10px; 
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .top-right { 
            top: 10px; 
            right: 10px; 
        }
        .bottom-center { 
            bottom: 10px; 
            left: 50%; 
            transform: translateX(-50%); 
            text-align: center; 
        }
        .hidden { 
            display: none !important; 
        }
        #healthBar {
            position: relative;
            width: 150px;
            height: 16px;
            border: 2px solid #A3DFFF;
            background-color: #2A4859;
            border-radius: 4px;
            box-shadow: 0 0 8px rgba(163, 223, 255, 0.4); /* Glow effect */
        }
        #healthBarInner {
            height: 100%;
            background: linear-gradient(to right, #FF4040, #FF6666);
            border-radius: 2px;
            width: 100%;
            transition: width 0.3s ease;
            box-shadow: inset 0 0 5px rgba(255, 102, 102, 0.6); /* Inner glow */
        }
        .home-button {
            display: inline-block;
            padding: 8px 16px;
            background-color: #0585e6;
            border: 2px solid #A3DFFF;
            border-radius: 5px;
            color: #A3DFFF;
            text-decoration: none;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.3s;
            box-shadow: 0 0 8px rgba(5, 133, 230, 0.5); /* Button glow */
        }
        .home-button:hover {
            background-color: #0268b5;
            transform: scale(1.05);
            box-shadow: 0 0 12px rgba(5, 133, 230, 0.8);
        }
        .home-button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px rgba(5, 133, 230, 0.3);
        }
        @font-face {
            font-family: 'Press Start 2P';
            src: url('/fonts/PressStart2P-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
    </style>
{% endblock %}

{% block body %}
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="game-ui top-left">
            <label class="flex items-center">
                <input type="checkbox" id="soundToggle" class="mr-2">
                Activer le son
            </label>
            <div id="healthBar"><div id="healthBarInner"></div></div>
        </div>
        <div class="game-ui top-right">
            <p id="scoreLevelDisplay"></p>
        </div>
        <div class="game-ui bottom-center">
            <p>Flèches/QWSD: Bouger, ESPACE: Tirer, U: Améliorations, E: Dash, Shift: Mode de tir<br>
            <a href="{{ path('app_home') }}" class="home-button">Retour à l'accueil</a></p>
        </div>
    </div>

    <script>
        (function() {
            'use strict';

            // Constants
            const PIXEL_GRID = 16;
            const DASH_DURATION = 200;
            const DASH_SPEED = 600;
            const INVINCIBILITY_DURATION = 1000;
            const JOYSTICK_DEADZONE = 10;
            const JOYSTICK_MAX_DISTANCE = 75;
            const MAX_FPS = 60;
            const FRAME_TIME = 1000 / MAX_FPS;

            // Palette
            const palette = {
                primary: '#3D6A80',
                primaryDark: '#2A4859',
                secondary: '#A3DFFF',
                secondaryDark: '#6B9EBF',
                accent: '#FF4040',
                accentDark: '#B22222',
                background: '#0A1C2B',
                highlight: '#FFB380'
            };

            // DOM Elements
            const container = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d', { alpha: false });
            const soundToggle = document.getElementById('soundToggle');
            const healthBarInner = document.getElementById('healthBarInner');
            const scoreLevelDisplay = document.getElementById('scoreLevelDisplay');

            // Validation
            if (!container || !canvas || !ctx || !soundToggle || !healthBarInner || !scoreLevelDisplay) {
                console.error('Missing required DOM elements');
                return;
            }

            // Game State
         let state = {
    scaleX: 1,
    scaleY: 1,
    scale: 1,
    gameStarted: false,
    gameOver: false,
    bossDefeated: false, // New flag to prevent boss respawn
    spawnTimes: {
        packet: 0,
        asteroid: 0,
        comet: 0,
        blackHole: 0,
        drone: 0,
        kamikazeDrone: 0,
        buff: 0
    },
    gameTime: 0,
    score: 0,
    combo: 0,
    level: 1,
    enemiesDestroyed: 0,
    highScore: parseInt(localStorage.getItem('highScore')) || 0,
    leaderboard: JSON.parse(localStorage.getItem('leaderboard')) || [],
    achievements: JSON.parse(localStorage.getItem('achievements')) || {
        collector: false,
        survivor: false,
        sharpshooter: false
    }
};

            // Game Objects
            let astronaut = {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                baseSpeed: 200,
                speed: 200,
                health: 200,
                invincibility: 0,
                shootCooldown: 0,
                dashDirection: { x: 0, y: 0 },
                velocity: { x: 0, y: 0 },
                state: 'idle',
                frame: 0,
                frameCount: 0,
                isDashing: false,
                dashTime: 0,
                dashCooldown: 0
            };

            let entities = {
                packets: [],
                asteroids: [],
                comets: [],
                blackHoles: [],
                buffs: [],
                drones: [],
                projectiles: [],
                boss: null
            };

            let bossState = {
        health: 300, // Increased health for more challenging boss
        phase: 1,
        attackCooldown: 0,
        lastBarrageTime: 0
    };

            let ui = {
                showUpgradeMenu: false,
                shakeTime: 0,
                shakeIntensity: 0,
                comboTimeout: null,
                speedBoostActive: false,
                speedBoostTimeout: null
            };

            let input = {
                keys: new Map(),
                joystick: { active: false, x: 0, y: 0, baseX: 0, baseY: 0 },
                state: {
                    direction: { x: 0, y: 0 },
                    shoot: false,
                    dash: false,
                    toggleFireMode: false,
                    openUpgradeMenu: false
                },
                lastInputType: null,
                fireMode: 'single',
                uKeyPressed: false // New flag to track 'U' key state
            };

            let upgrades = {
                speed: { level: 1, cost: 10, maxLevel: 3 },
                health: { level: 1, cost: 15, maxLevel: 3 },
                fireRate: { level: 1, cost: 12, maxLevel: 3 },
                dash: { level: 1, cost: 15, maxLevel: 3 }
            };

            // Enhanced Backgrounds with Particles
            let backgrounds = [
                { x: 0, y: 0, speed: 10, elements: [], type: 'stars' },
                { x: 0, y: 0, speed: 5, elements: [], type: 'nebula' },
                { x: 0, y: 0, speed: 15, elements: [], type: 'particles' }
            ];

            // Particle Effects
            let particles = [];

            // Audio
            let audioCtx = null;
            let soundEnabled = false;
            let backgroundMusic = null;
            let bassMusic = null;

            // Performance
            let lastTime = performance.now();
            let frameCount = 0;
            let lastFpsTime = performance.now();
            let fps = 60;
            let collidedThisFrame = new Set();

            // Spatial Partitioning
            let grid = null;
            const GRID_CELL_SIZE = 100;

            function initGrid() {
                grid = [];
                const cols = Math.ceil(canvas.width / GRID_CELL_SIZE);
                const rows = Math.ceil(canvas.height / GRID_CELL_SIZE);
                for (let i = 0; i < cols; i++) {
                    grid[i] = [];
                    for (let j = 0; j < rows; j++) {
                        grid[i][j] = [];
                    }
                }
            }

            function addToGrid(entity, x, y, width, height) {
                const left = Math.max(0, Math.floor(x / GRID_CELL_SIZE));
                const right = Math.min(Math.floor((x + width) / GRID_CELL_SIZE), grid.length - 1);
                const top = Math.max(0, Math.floor(y / GRID_CELL_SIZE));
                const bottom = Math.min(Math.floor((y + height) / GRID_CELL_SIZE), grid[0].length - 1);
                for (let i = left; i <= right; i++) {
                    for (let j = top; j <= bottom; j++) {
                        grid[i][j].push(entity);
                    }
                }
            }

            function getNearbyEntities(x, y, width, height) {
                const left = Math.max(0, Math.floor(x / GRID_CELL_SIZE) - 1);
                const right = Math.min(Math.floor((x + width) / GRID_CELL_SIZE) + 1, grid.length - 1);
                const top = Math.max(0, Math.floor(y / GRID_CELL_SIZE) - 1);
                const bottom = Math.min(Math.floor((y + height) / GRID_CELL_SIZE) + 1, grid[0].length - 1);
                const entities = new Set();
                for (let i = left; i <= right; i++) {
                    for (let j = top; j <= bottom; j++) {
                        grid[i][j].forEach(e => entities.add(e));
                    }
                }
                return Array.from(entities);
            }

            function clearGrid() {
                for (let i = 0; i < grid.length; i++) {
                    for (let j = 0; j < grid[i].length; j++) {
                        grid[i][j].length = 0;
                    }
                }
            }

            // Utility Functions
            function debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func(...args), wait);
                };
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                    const r = Math.random() * 16 | 0;
                    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                });
            }

            // Particle System
            function spawnParticles(x, y, count, type) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 100 * state.scale,
                        vy: (Math.random() - 0.5) * 100 * state.scale,
                        size: Math.random() * 3 * state.scale + 1,
                        life: type === 'explosion' ? 0.5 : 1,
                        color: type === 'explosion' ? '#FF6633' : '#A3DFFF',
                        type: type
                    });
                }
            }

            function updateParticles(deltaTime) {
                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => {
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.life -= deltaTime;
                    p.size *= 0.95; // Shrink over time
                });
            }

            function drawParticles() {
                particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life * (p.type === 'explosion' ? 0.8 : 0.5);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });
            }

            // Initialization
            function resizeCanvas() {
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = window.innerHeight * window.devicePixelRatio;
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight}px`;
                state.scaleX = canvas.width / 1200;
                state.scaleY = canvas.height / 800;
                state.scale = Math.min(state.scaleX, state.scaleY);
                astronaut.x = canvas.width / 4;
                astronaut.y = canvas.height / 2;
                astronaut.width = PIXEL_GRID * state.scale;
                astronaut.height = PIXEL_GRID * state.scale;
                astronaut.baseSpeed = 200 * state.scale;
                astronaut.speed = astronaut.baseSpeed;
                initBackgrounds();
                initGrid();
                updateHealthBar();
            }

            function initBackgrounds() {
                // Stars
                backgrounds[0].elements = Array.from({ length: 50 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 * state.scale + 1,
                    color: palette.secondary,
                    glow: Math.random() * 0.5 + 0.3
                }));
                // Nebula clouds
                backgrounds[1].elements = Array.from({ length: 5 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 100 * state.scale * (Math.random() * 0.5 + 0.5),
                    color: `rgba(107, 158, 191, ${Math.random() * 0.2 + 0.1})`
                }));
                // Cosmic dust particles
                backgrounds[2].elements = Array.from({ length: 20 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 * state.scale + 0.5,
                    color: `rgba(163, 223, 255, ${Math.random() * 0.3 + 0.2})`,
                    vx: (Math.random() - 0.5) * 20 * state.scale,
                    vy: (Math.random() - 0.5) * 20 * state.scale
                }));
            }

            // Audio Management
            function initAudio() {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                soundToggle.addEventListener('change', () => {
                    soundEnabled = soundToggle.checked;
                    if (soundEnabled && audioCtx.state === 'suspended') {
                        audioCtx.resume().catch(e => console.error('AudioContext resume failed:', e));
                    }
                    soundEnabled ? startBackgroundMusic() : stopBackgroundMusic();
                });
            }

            function playSound(type) {
                if (!soundEnabled || !audioCtx) return;
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.type = 'triangle';

                switch (type) {
                    case 'collect':
                        oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioCtx.currentTime + 0.3);
                        break;
                    case 'damage':
                        oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.4);
                        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
                        oscillator.start();
                        oscillator.stop(audioCtx.currentTime + 0.4);
                        break;
                    case 'shoot':
                        oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioCtx.currentTime + 0.2);
                        break;
                }
            }

            const melody = [
                { frequency: 220, duration: 500 },
                { frequency: 330, duration: 500 },
                { frequency: 440, duration: 500 },
                { frequency: 330, duration: 500 }
            ];
            const bassMelody = [
                { frequency: 110, duration: 1000 },
                { frequency: 165, duration: 1000 }
            ];

            function startBackgroundMusic() {
                if (!soundEnabled || backgroundMusic) return;
                backgroundMusic = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                backgroundMusic.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                backgroundMusic.type = 'triangle';
                gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 1);
                backgroundMusic.start();
                backgroundMusic.gainNode = gainNode;

                bassMusic = audioCtx.createOscillator();
                const bassGainNode = audioCtx.createGain();
                bassMusic.connect(bassGainNode);
                bassGainNode.connect(audioCtx.destination);
                bassMusic.type = 'sine';
                bassGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                bassGainNode.gain.linearRampToValueAtTime(0.015, audioCtx.currentTime + 1);
                bassMusic.start();
                bassMusic.gainNode = bassGainNode;

                let noteIndex = 0;
                let bassIndex = 0;

                function playNextNote() {
                    if (!backgroundMusic) return;
                    const note = melody[noteIndex];
                    backgroundMusic.frequency.exponentialRampToValueAtTime(note.frequency, audioCtx.currentTime + 0.1);
                    noteIndex = (noteIndex + 1) % melody.length;
                    setTimeout(playNextNote, note.duration);
                }

                function playNextBassNote() {
                    if (!bassMusic) return;
                    const note = bassMelody[bassIndex];
                    bassMusic.frequency.exponentialRampToValueAtTime(note.frequency, audioCtx.currentTime + 0.1);
                    bassIndex = (bassIndex + 1) % bassMelody.length;
                    setTimeout(playNextBassNote, note.duration);
                }

                playNextNote();
                playNextBassNote();
            }

            function stopBackgroundMusic() {
                if (backgroundMusic) {
                    const gainNode = backgroundMusic.gainNode;
                    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                    backgroundMusic.stop(audioCtx.currentTime + 0.5);
                    backgroundMusic = null;
                }
                if (bassMusic) {
                    const bassGainNode = bassMusic.gainNode;
                    bassGainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                    bassMusic.stop(audioCtx.currentTime + 0.5);
                    bassMusic = null;
                }
            }

            // Rendering
            function drawBackgrounds(deltaTime) {
                ctx.fillStyle = palette.background;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                backgrounds.forEach(layer => {
                    layer.x -= layer.speed * deltaTime;
                    if (layer.x < -canvas.width) layer.x += canvas.width;
                    layer.elements.forEach(el => {
                        if (layer.type === 'stars') {
                            ctx.beginPath();
                            ctx.arc(el.x + layer.x, el.y, el.size, 0, Math.PI * 2);
                            ctx.fillStyle = el.color;
                            ctx.globalAlpha = el.glow * (1 + 0.2 * Math.sin(state.gameTime * 0.001)); // Subtle glow pulse
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        } else if (layer.type === 'nebula') {
                            const gradient = ctx.createRadialGradient(el.x + layer.x, el.y, 0, el.x + layer.x, el.y, el.size);
                            gradient.addColorStop(0, el.color);
                            gradient.addColorStop(1, 'rgba(10, 28, 43, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(el.x + layer.x, el.y, el.size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (layer.type === 'particles') {
                            el.x += el.vx * deltaTime;
                            el.y += el.vy * deltaTime;
                            if (el.x < 0) el.x += canvas.width;
                            if (el.x > canvas.width) el.x -= canvas.width;
                            if (el.y < 0) el.y += canvas.height;
                            if (el.y > canvas.height) el.y -= canvas.height;
                            ctx.beginPath();
                            ctx.arc(el.x + layer.x, el.y, el.size, 0, Math.PI * 2);
                            ctx.fillStyle = el.color;
                            ctx.globalAlpha = 0.5 * (1 + 0.3 * Math.sin(state.gameTime * 0.002));
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    });
                });
            }

            function drawDitheredRect(ctx, x, y, width, height, color1, color2, pixelSize) {
                if (width * height > 1000 * state.scale * state.scale) {
                    ctx.fillStyle = color1;
                    ctx.fillRect(x, y, width, height);
                    return;
                }
                for (let i = 0; i < width; i += pixelSize) {
                    for (let j = 0; j < height; j += pixelSize) {
                        ctx.fillStyle = (i / pixelSize + j / pixelSize) % 2 === 0 ? color1 : color2;
                        ctx.fillRect(x + i, y + j, pixelSize, pixelSize);
                    }
                }
            }

            function drawAstronaut() {
                ctx.save();
                ctx.translate(astronaut.x + astronaut.width / 2, astronaut.y + astronaut.height / 2);
                if (astronaut.invincibility > 0 && Math.floor(astronaut.frameCount / 5) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                if (astronaut.state === 'moving' && astronaut.frameCount % 8 < 4) {
                    ctx.rotate(Math.PI / 16);
                }

                const colors = {
                    helmet: '#D5F6FF',
                    helmetShade: '#8AB8D9',
                    body: '#4A7A96',
                    bodyShade: '#355565',
                    accent: '#FF6666',
                    exhaust: '#FFD700',
                    visor: '#1A2C38',
                    detail: '#FFFFFF',
                    glow: 'rgba(163, 223, 255, 0.4)'
                };

                // Dash trail effect
                if (astronaut.isDashing) {
                    const trailGradient = ctx.createLinearGradient(0, 0, -PIXEL_GRID * 1.5 * state.scale, 0);
                    trailGradient.addColorStop(0, colors.glow);
                    trailGradient.addColorStop(1, 'rgba(163, 223, 255, 0)');
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.moveTo(PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.5 * state.scale);
                    ctx.lineTo(-PIXEL_GRID * 1.5 * state.scale, -PIXEL_GRID * 0.3 * state.scale);
                    ctx.lineTo(-PIXEL_GRID * 1.5 * state.scale, PIXEL_GRID * 0.3 * state.scale);
                    ctx.lineTo(PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * 0.5 * state.scale);
                    ctx.fill();
                }

                // Helmet with enhanced gradient
                const gradientHelmet = ctx.createLinearGradient(-PIXEL_GRID / 2 * state.scale, -PIXEL_GRID / 2 * state.scale, PIXEL_GRID / 2 * state.scale, PIXEL_GRID / 2 * state.scale);
                gradientHelmet.addColorStop(0, colors.helmet);
                gradientHelmet.addColorStop(0.5, colors.helmetShade);
                gradientHelmet.addColorStop(1, colors.helmet);
                ctx.fillStyle = gradientHelmet;
                ctx.beginPath();
                ctx.arc(0, -PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.6 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = colors.visor;
                ctx.fillRect(-PIXEL_GRID * 0.4 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * 0.8 * state.scale, PIXEL_GRID * 0.4 * state.scale);
                ctx.fillStyle = colors.detail;
                ctx.fillRect(-PIXEL_GRID * 0.3 * state.scale, -PIXEL_GRID * 0.4 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.1 * state.scale); // Visor highlight
                ctx.fillRect(PIXEL_GRID * 0.1 * state.scale, -PIXEL_GRID * 0.4 * state.scale, PIXEL_GRID * 0.1 * state.scale, PIXEL_GRID * 0.05 * state.scale); // Extra detail

                // Body with detailed shading
                ctx.fillStyle = colors.body;
                ctx.fillRect(-PIXEL_GRID * 0.4 * state.scale, -PIXEL_GRID * 0.1 * state.scale, PIXEL_GRID * 0.8 * state.scale, PIXEL_GRID * 0.9 * state.scale);
                drawDitheredRect(
                    ctx,
                    -PIXEL_GRID * 0.4 * state.scale,
                    -PIXEL_GRID * 0.1 * state.scale,
                    PIXEL_GRID * 0.8 * state.scale,
                    PIXEL_GRID * 0.4 * state.scale,
                    colors.body,
                    colors.bodyShade,
                    state.scale
                );
                ctx.fillStyle = colors.accent;
                ctx.fillRect(-PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.3 * state.scale); // Left panel
                ctx.fillRect(PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.3 * state.scale); // Right panel
                ctx.fillStyle = colors.detail;
                ctx.fillRect(-PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.1 * state.scale, PIXEL_GRID * 0.1 * state.scale); // Small detail

                // Legs with animation
                ctx.fillStyle = colors.bodyShade;
                ctx.fillRect(-PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.6 * state.scale, PIXEL_GRID * 0.25 * state.scale, PIXEL_GRID * 0.4 * state.scale);
                ctx.fillRect(PIXEL_GRID * 0.05 * state.scale, PIXEL_GRID * 0.6 * state.scale, PIXEL_GRID * 0.25 * state.scale, PIXEL_GRID * 0.4 * state.scale);

                // Enhanced exhaust animation
                if (astronaut.state === 'moving' && astronaut.frame % 4 < 2) {
                    const exhaustGradient = ctx.createRadialGradient(0, PIXEL_GRID * 0.9 * state.scale, 0, 0, PIXEL_GRID * 0.9 * state.scale, PIXEL_GRID * 0.4 * state.scale);
                    exhaustGradient.addColorStop(0, colors.exhaust);
                    exhaustGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.6)');
                    exhaustGradient.addColorStop(1, 'rgba(255, 215, 0, 0.2)');
                    ctx.fillStyle = exhaustGradient;
                    ctx.beginPath();
                    ctx.moveTo(-PIXEL_GRID * 0.25 * state.scale, PIXEL_GRID * 0.9 * state.scale);
                    ctx.lineTo(PIXEL_GRID * 0.25 * state.scale, PIXEL_GRID * 0.9 * state.scale);
                    ctx.lineTo(0, PIXEL_GRID * (1.2 + 0.1 * Math.sin(state.gameTime * 0.01)) * state.scale); // Flicker effect
                    ctx.closePath();
                    ctx.fill();
                }

                if (astronaut.isDashing) {
                    ctx.fillStyle = colors.glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, PIXEL_GRID * 0.8 * state.scale, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalAlpha = 1;
                ctx.restore();
                astronaut.frame = (astronaut.frame + 1) % 20;
                astronaut.frameCount = (astronaut.frameCount + 1) % 32;
            }

            function drawPacket(packet) {
                ctx.save();
                ctx.translate(packet.x + packet.width / 2, packet.y + packet.height / 2);
                ctx.rotate(Math.sin(packet.x * 0.01 + state.gameTime * 0.001) * 0.1); // Enhanced wobble

                // Core packet with glowing effect
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, PIXEL_GRID * 0.6 * state.scale);
                gradient.addColorStop(0, '#FF99FF');
                gradient.addColorStop(0.5, '#FF66CC');
                gradient.addColorStop(1, '#FF33CC');
                ctx.fillStyle = gradient;
                ctx.fillRect(-PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * state.scale, PIXEL_GRID * state.scale);
                drawDitheredRect(
                    ctx,
                    -PIXEL_GRID * 0.5 * state.scale,
                    -PIXEL_GRID * 0.5 * state.scale,
                    PIXEL_GRID * state.scale,
                    PIXEL_GRID * 0.3 * state.scale,
                    '#FF33CC',
                    '#CC0099',
                    state.scale
                );

                // Data core with pulse
                ctx.fillStyle = '#66FFFF';
                ctx.beginPath();
                ctx.arc(0, 0, PIXEL_GRID * 0.3 * state.scale * (1 + 0.1 * Math.sin(state.gameTime * 0.002)), 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-PIXEL_GRID * 0.1 * state.scale, -PIXEL_GRID * 0.1 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.2 * state.scale); // Sparkle
                ctx.fillRect(PIXEL_GRID * 0.05 * state.scale, PIXEL_GRID * 0.05 * state.scale, PIXEL_GRID * 0.1 * state.scale, PIXEL_GRID * 0.1 * state.scale); // Extra sparkle

                ctx.restore();
            }

            function drawAsteroid(asteroid) {
                ctx.save();
                ctx.translate(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2);
                ctx.rotate(asteroid.rotation);

                // Enhanced jagged asteroid shape
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, PIXEL_GRID * state.scale);
                gradient.addColorStop(0, '#888888');
                gradient.addColorStop(0.7, '#666666');
                gradient.addColorStop(1, '#444444');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(-PIXEL_GRID * 0.9 * state.scale, -PIXEL_GRID * 0.8 * state.scale);
                ctx.lineTo(-PIXEL_GRID * 0.3 * state.scale, -PIXEL_GRID * 1.2 * state.scale);
                ctx.lineTo(PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.9 * state.scale);
                ctx.lineTo(PIXEL_GRID * 1.2 * state.scale, -PIXEL_GRID * 0.2 * state.scale);
                ctx.lineTo(PIXEL_GRID * 0.9 * state.scale, PIXEL_GRID * 0.8 * state.scale);
                ctx.lineTo(PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 1.2 * state.scale);
                ctx.lineTo(-PIXEL_GRID * 0.7 * state.scale, PIXEL_GRID * 0.9 * state.scale);
                ctx.lineTo(-PIXEL_GRID * 1.2 * state.scale, PIXEL_GRID * 0.2 * state.scale);
                ctx.closePath();
                ctx.fill();

                // Detailed craters
                ctx.fillStyle = '#AAAAAA';
                ctx.beginPath();
                ctx.arc(PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.3 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-PIXEL_GRID * 0.4 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * 0.2 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(PIXEL_GRID * 0.2 * state.scale, -PIXEL_GRID * 0.6 * state.scale, PIXEL_GRID * 0.15 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                drawDitheredRect(
                    ctx,
                    -PIXEL_GRID * 0.6 * state.scale,
                    -PIXEL_GRID * 0.9 * state.scale,
                    PIXEL_GRID * 1.2 * state.scale,
                    PIXEL_GRID * 0.3 * state.scale,
                    '#777777',
                    '#555555',
                    state.scale
                );

                ctx.restore();
                asteroid.rotation += asteroid.rotationSpeed;
            }

            function drawComet(comet) {
                ctx.save();
                ctx.translate(comet.x + comet.width / 2, comet.y + comet.height / 2);
                ctx.rotate(comet.rotation);

                // Fiery comet core
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, PIXEL_GRID * 0.5 * state.scale);
                gradient.addColorStop(0, '#FF9933');
                gradient.addColorStop(0.5, '#FF6633');
                gradient.addColorStop(1, '#CC3300');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, PIXEL_GRID * 0.5 * state.scale, 0, Math.PI * 2);
                ctx.fill();

                // Enhanced glowing tail
                const tailGradient = ctx.createLinearGradient(PIXEL_GRID * 0.5 * state.scale, 0, PIXEL_GRID * 1.5 * state.scale, 0);
                tailGradient.addColorStop(0, 'rgba(255, 153, 51, 0.8)');
                tailGradient.addColorStop(1, 'rgba(255, 153, 51, 0.1)');
                ctx.fillStyle = tailGradient;
                ctx.beginPath();
                ctx.moveTo(PIXEL_GRID * 0.5 * state.scale, 0);
                ctx.lineTo(PIXEL_GRID * 1.5 * state.scale, -PIXEL_GRID * 0.4 * state.scale);
                ctx.lineTo(PIXEL_GRID * 1.5 * state.scale, PIXEL_GRID * 0.4 * state.scale);
                ctx.closePath();
                ctx.fill();

                // Surface details
                ctx.fillStyle = '#FFCC99';
                ctx.beginPath();
                ctx.arc(-PIXEL_GRID * 0.2 * state.scale, 0, PIXEL_GRID * 0.2 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-PIXEL_GRID * 0.1 * state.scale, PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.15 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                drawDitheredRect(
                    ctx,
                    -PIXEL_GRID * 0.3 * state.scale,
                    -PIXEL_GRID * 0.3 * state.scale,
                    PIXEL_GRID * 0.6 * state.scale,
                    PIXEL_GRID * 0.2 * state.scale,
                    '#FF6633',
                    '#FF9933',
                    state.scale
                );

                ctx.restore();
                comet.rotation += comet.rotationSpeed;
            }

          function drawBlackHole(blackHole) {
    ctx.save();
    ctx.translate(blackHole.x + blackHole.width / 2, blackHole.y + blackHole.height / 2);
    ctx.rotate(blackHole.rotation);

    // Enhanced swirling core (unchanged)
    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, PIXEL_GRID * 0.7 * state.scale);
    coreGradient.addColorStop(0, '#FFFFFF');
    coreGradient.addColorStop(0.2, '#CC99FF');
    coreGradient.addColorStop(0.5, '#9933FF');
    coreGradient.addColorStop(1, '#330066');
    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(0, 0, PIXEL_GRID * 0.7 * state.scale * (1 + 0.1 * Math.sin(blackHole.rotation * 2)), 0, Math.PI * 2);
    ctx.fill();

    // Reduced visual pull radius for accretion disk and outer ring
    const visualPullRadius = blackHole.pullRadius * 0.5; // 50% of original pullRadius (150 * state.scale)

    // Detailed accretion disk with reduced radius
    ctx.strokeStyle = 'rgba(163, 223, 255, 0.7)';
    ctx.lineWidth = 4 * state.scale;
    for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        const angle = (Math.PI / 3) * i + blackHole.rotation * 3;
        const radius = visualPullRadius * (1 - i * 0.15); // Scale accretion disk to visual radius
        ctx.quadraticCurveTo(
            Math.cos(angle) * radius * 0.5,
            Math.sin(angle) * radius * 0.5,
            Math.cos(angle + Math.PI / 2) * radius,
            Math.sin(angle + Math.PI / 2) * radius
        );
        ctx.stroke();
    }

    // Outer ring with glow, reduced radius
    const ringGradient = ctx.createRadialGradient(0, 0, visualPullRadius * 0.8, 0, 0, visualPullRadius);
    ringGradient.addColorStop(0, 'rgba(163, 223, 255, 0.6)');
    ringGradient.addColorStop(1, 'rgba(163, 223, 255, 0.2)');
    ctx.strokeStyle = ringGradient;
    ctx.lineWidth = 6 * state.scale;
    ctx.beginPath();
    ctx.arc(0, 0, visualPullRadius * 0.9, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
    blackHole.rotation += blackHole.rotationSpeed;
}

         function drawBoss() {
        if (!entities.boss) return;
        ctx.save();
        ctx.translate(entities.boss.x + entities.boss.width / 2, entities.boss.y + entities.boss.height / 2);
        ctx.rotate(entities.boss.rotation);

        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, entities.boss.width / 2);
        coreGradient.addColorStop(0, '#FF33CC');
        coreGradient.addColorStop(0.5, '#CC00FF');
        coreGradient.addColorStop(1, '#660099');
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, entities.boss.width / 2 * (1 + 0.05 * Math.sin(state.gameTime * 0.003)), 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#FFCC00';
        for (let i = 0; i < 6; i++) { // More energy cores
            const angle = (Math.PI / 3) * i + entities.boss.rotation;
            ctx.beginPath();
            ctx.arc(
                Math.cos(angle) * (entities.boss.width * 0.4),
                Math.sin(angle) * (entities.boss.width * 0.4),
                PIXEL_GRID * 0.4 * state.scale * (1 + 0.1 * Math.sin(state.gameTime * 0.002 + i)),
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        if (astronaut.frame % 4 < 2) {
            const eyeGradient = ctx.createRadialGradient(PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.7 * state.scale, 0, PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.7 * state.scale, PIXEL_GRID * 0.5 * state.scale);
            eyeGradient.addColorStop(0, '#FF6666');
            eyeGradient.addColorStop(1, '#FF3333');
            ctx.fillStyle = eyeGradient;
            ctx.beginPath();
            ctx.arc(PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.7 * state.scale, PIXEL_GRID * 0.5 * state.scale, 0, Math.PI * 2);
            ctx.arc(-PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.7 * state.scale, PIXEL_GRID * 0.5 * state.scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.7 * state.scale, PIXEL_GRID * 0.15 * state.scale, 0, Math.PI * 2);
            ctx.arc(-PIXEL_GRID * 0.7 * state.scale, -PIXEL_GRID * 0.7 * state.scale, PIXEL_GRID * 0.15 * state.scale, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.strokeStyle = 'rgba(163, 223, 255, 0.8)';
        ctx.lineWidth = 6 * state.scale;
        for (let i = 0; i < 12; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, entities.boss.width / 2 + 20 * state.scale, i * (Math.PI / 6) + entities.boss.rotation * 2, i * (Math.PI / 6) + Math.PI / 12 + entities.boss.rotation * 2);
            ctx.stroke();
        }

        ctx.restore();
        entities.boss.rotation += entities.boss.rotationSpeed;

        const healthGradient = ctx.createLinearGradient(entities.boss.x, 0, entities.boss.x + entities.boss.width, 0);
        healthGradient.addColorStop(0, '#FF6666');
        healthGradient.addColorStop(1, '#FF3333');
        ctx.fillStyle = healthGradient;
        ctx.fillRect(entities.boss.x, entities.boss.y - 30 * state.scale, (bossState.health / 300) * entities.boss.width, 15 * state.scale);
        ctx.strokeStyle = '#A3DFFF';
        ctx.lineWidth = 3 * state.scale;
        ctx.strokeRect(entities.boss.x, entities.boss.y - 30 * state.scale, entities.boss.width, 15 * state.scale);
        ctx.fillStyle = 'rgba(163, 223, 255, 0.4)';
        ctx.fillRect(entities.boss.x, entities.boss.y - 30 * state.scale, entities.boss.width, 15 * state.scale);
    }
            function drawDrone(drone) {
                ctx.save();
                ctx.translate(drone.x + drone.width / 2, drone.y + drone.height / 2);
                ctx.rotate(Math.sin(drone.x * 0.02 + state.gameTime * 0.001) * 0.05); // Enhanced oscillation

                // Drone body
                const bodyColor = drone.type === 'kamikaze' ? '#FF5533' : drone.type === 'micro' ? '#999999' : '#666666';
                const shadeColor = drone.type === 'kamikaze' ? '#CC3300' : drone.type === 'micro' ? '#777777' : '#444444';
                const gradient = ctx.createLinearGradient(-PIXEL_GRID * 0.5 * state.scale, 0, PIXEL_GRID * 0.5 * state.scale, 0);
                gradient.addColorStop(0, bodyColor);
                gradient.addColorStop(1, shadeColor);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(-PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.4 * state.scale);
                ctx.lineTo(PIXEL_GRID * 0.5 * state.scale, 0);
                ctx.lineTo(-PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * 0.4 * state.scale);
                ctx.closePath();
                ctx.fill();

                // Core detail with blinking light
                ctx.fillStyle = drone.type === 'kamikaze' ? '#FFCC00' : '#FF3333';
                ctx.beginPath();
                ctx.arc(0, 0, PIXEL_GRID * 0.25 * state.scale, 0, Math.PI * 2);
                ctx.fill();
                if (astronaut.frame % 8 < 4) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(PIXEL_GRID * 0.2 * state.scale, 0, PIXEL_GRID * 0.1 * state.scale, 0, Math.PI * 2);
                    ctx.fill(); // Blinking light
                }
                drawDitheredRect(
                    ctx,
                    -PIXEL_GRID * 0.3 * state.scale,
                    -PIXEL_GRID * 0.4 * state.scale,
                    PIXEL_GRID * 0.6 * state.scale,
                    PIXEL_GRID * 0.2 * state.scale,
                    bodyColor,
                    shadeColor,
                    state.scale
                );

                ctx.restore();
            }

            function drawBuff(buff) {
                ctx.save();
                ctx.translate(buff.x + buff.width / 2, buff.y + buff.height / 2);
                ctx.rotate(Math.sin(buff.x * 0.01 + state.gameTime * 0.001) * 0.1); // Enhanced rotation

                if (buff.type === 'speed') {
                    // Speed buff with lightning bolt
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, PIXEL_GRID * 0.5 * state.scale);
                    gradient.addColorStop(0, '#33FF33');
                    gradient.addColorStop(1, '#00CC00');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * state.scale, PIXEL_GRID * state.scale);
                    ctx.fillStyle = '#FFFF66';
                    ctx.beginPath();
                    ctx.moveTo(-PIXEL_GRID * 0.2 * state.scale, -PIXEL_GRID * 0.3 * state.scale);
                    ctx.lineTo(PIXEL_GRID * 0.2 * state.scale, -PIXEL_GRID * 0.3 * state.scale);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.3 * state.scale);
                    ctx.lineTo(-PIXEL_GRID * 0.2 * state.scale, PIXEL_GRID * 0.3 * state.scale);
                    ctx.lineTo(0, 0);
                    ctx.closePath();
                    ctx.fill();
                    drawDitheredRect(
                        ctx,
                        -PIXEL_GRID * 0.5 * state.scale,
                        -PIXEL_GRID * 0.5 * state.scale,
                        PIXEL_GRID * state.scale,
                        PIXEL_GRID * 0.2 * state.scale,
                        '#33FF33',
                        '#00CC00',
                        state.scale
                    );
                } else if (buff.type === 'health') {
                    // Health buff with cross
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, PIXEL_GRID * 0.5 * state.scale);
                    gradient.addColorStop(0, '#FF3333');
                    gradient.addColorStop(1, '#CC0000');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * state.scale, PIXEL_GRID * state.scale);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(-PIXEL_GRID * 0.15 * state.scale, -PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.3 * state.scale, PIXEL_GRID * 0.6 * state.scale);
                    ctx.fillRect(-PIXEL_GRID * 0.3 * state.scale, -PIXEL_GRID * 0.15 * state.scale, PIXEL_GRID * 0.6 * state.scale, PIXEL_GRID * 0.3 * state.scale);
                    drawDitheredRect(
                        ctx,
                        -PIXEL_GRID * 0.5 * state.scale,
                        -PIXEL_GRID * 0.5 * state.scale,
                        PIXEL_GRID * state.scale,
                        PIXEL_GRID * 0.2 * state.scale,
                        '#FF3333',
                        '#CC0000',
                        state.scale
                    );
                }

                // Enhanced outline with glow
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2 * state.scale;
                ctx.strokeRect(-PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * state.scale, PIXEL_GRID * state.scale);
                ctx.strokeStyle = 'rgba(163, 223, 255, 0.4)';
                ctx.lineWidth = 4 * state.scale;
                ctx.strokeRect(-PIXEL_GRID * 0.5 * state.scale, -PIXEL_GRID * 0.5 * state.scale, PIXEL_GRID * state.scale, PIXEL_GRID * state.scale);

                ctx.restore();
            }

            function drawProjectile(projectile) {
                ctx.save();
                ctx.translate(projectile.x, projectile.y);
                const gradient = ctx.createLinearGradient(0, -projectile.height / 2, 0, projectile.height / 2);
                gradient.addColorStop(0, projectile.isEnemy ? '#FFCC00' : '#FF6666');
                gradient.addColorStop(1, projectile.isEnemy ? '#FF6600' : '#CC3333');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, -projectile.height / 2);
                ctx.lineTo(projectile.width, -projectile.height / 4);
                ctx.lineTo(projectile.width, projectile.height / 4);
                ctx.lineTo(0, projectile.height / 2);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(projectile.width * 0.3, -projectile.height * 0.1, projectile.width * 0.4, projectile.height * 0.2); // Spark
                drawDitheredRect(
                    ctx,
                    0,
                    -projectile.height / 2,
                    projectile.width,
                    projectile.height * 0.3,
                    projectile.isEnemy ? '#FFCC00' : '#FF6666',
                    projectile.isEnemy ? '#FF6600' : '#CC3333',
                    state.scale
                );
                // Trail effect
                const trailGradient = ctx.createLinearGradient(0, 0, -projectile.width * 2, 0);
                trailGradient.addColorStop(0, 'rgba(255, 102, 102, 0.5)');
                trailGradient.addColorStop(1, 'rgba(255, 102, 102, 0)');
                ctx.fillStyle = trailGradient;
                ctx.fillRect(-projectile.width * 2, -projectile.height / 4, projectile.width * 2, projectile.height / 2);
                ctx.restore();
            }

            function drawIntroScreen() {
                ctx.fillStyle = palette.background;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                drawBackgrounds(0); // Show background in intro
                ctx.fillStyle = palette.secondary;
                ctx.font = `20px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Galactic Error 404', canvas.width / 2, canvas.height / 2 - 60 * state.scale);
                ctx.font = `12px 'Press Start 2P', monospace`;
                ctx.fillText('The cosmic network has crashed!', canvas.width / 2, canvas.height / 2 - 20 * state.scale);
                ctx.fillText('Collect 100 data packets to restore it.', canvas.width / 2, canvas.height / 2);
                ctx.fillText('Avoid asteroids, comets, and drones.', canvas.width / 2, canvas.height / 2 + 20 * state.scale);
                ctx.fillText('Leaderboard:', canvas.width / 2, canvas.height / 2 + 40 * state.scale);
                state.leaderboard.slice(0, 5).forEach((score, i) => {
                    ctx.fillText(`${i + 1}. ${score}`, canvas.width / 2, canvas.height / 2 + (60 + i * 20) * state.scale);
                });
                ctx.fillStyle = palette.accent;
                ctx.fillText('Press SPACE to start', canvas.width / 2, canvas.height / 2 + (60 + state.leaderboard.length * 20) * state.scale);
            }

            function drawUpgradeMenu() {
                if (!ui.showUpgradeMenu) return;
                // Sci-fi panel effect
                ctx.fillStyle = 'rgba(10, 28, 43, 0.95)';
                ctx.fillRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 2);
                ctx.strokeStyle = 'rgba(163, 223, 255, 0.6)';
                ctx.lineWidth = 4 * state.scale;
                ctx.strokeRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = 'rgba(163, 223, 255, 0.2)';
                ctx.fillRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 2); // Glow overlay
                ctx.fillStyle = palette.secondary;
                ctx.font = `16px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                ctx.fillText('Upgrades', canvas.width / 2, canvas.height / 4 + 30 * state.scale);
                ctx.font = `12px 'Press Start 2P', monospace`;
                ctx.fillText(`Score: ${state.score}`, canvas.width / 2, canvas.height / 4 + 50 * state.scale);
                ctx.fillText(`Speed (Level ${upgrades.speed.level}): ${upgrades.speed.cost} [1]`, canvas.width / 2, canvas.height / 4 + 80 * state.scale);
                ctx.fillText(`Health (Level ${upgrades.health.level}): ${upgrades.health.cost} [2]`, canvas.width / 2, canvas.height / 4 + 100 * state.scale);
                ctx.fillText(`Fire Rate (Level ${upgrades.fireRate.level}): ${upgrades.fireRate.cost} [3]`, canvas.width / 2, canvas.height / 4 + 120 * state.scale);
                ctx.fillText(`Dash (Level ${upgrades.dash.level}): ${upgrades.dash.cost} [4]`, canvas.width / 2, canvas.height / 4 + 140 * state.scale);
                ctx.fillText('Press U to close', canvas.width / 2, canvas.height / 4 + 160 * state.scale);
            }

            function drawJoystick() {
                if (!input.joystick.active) return;
                ctx.beginPath();
                ctx.arc(input.joystick.baseX, input.joystick.baseY, 50 * state.scale, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(163, 223, 255, 0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(input.joystick.x, input.joystick.y, 20 * state.scale, 0, Math.PI * 2);
                ctx.fillStyle = palette.secondary;
                ctx.fill();
                ctx.strokeStyle = 'rgba(163, 223, 255, 0.6)';
                ctx.lineWidth = 2 * state.scale;
                ctx.stroke(); // Glow outline
            }

            function drawReplayButton() {
                const buttonWidth = 200 * state.scale;
                const buttonHeight = 60 * state.scale;
                const buttonX = canvas.width / 2 - buttonWidth / 2;
                const buttonY = canvas.height / 2 + 140 * state.scale;
                ctx.fillStyle = '#0585e6';
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
                ctx.strokeStyle = palette.secondary;
                ctx.lineWidth = 4 * state.scale;
                ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
                ctx.fillStyle = 'rgba(163, 223, 255, 0.4)';
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight); // Glow overlay
                ctx.fillStyle = palette.secondary;
                ctx.font = `20px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Replay', canvas.width / 2, buttonY + buttonHeight / 2);
                return { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight };
            }

            // Game Logic
            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            function takeDamage(amount) {
                if (astronaut.invincibility <= 0 && !astronaut.isDashing) {
                    astronaut.health -= amount;
                    astronaut.invincibility = INVINCIBILITY_DURATION;
                    updateHealthBar();
                    playSound('damage');
                    ui.shakeTime = 300;
                    ui.shakeIntensity = 5 * state.scale;
                    spawnParticles(astronaut.x + astronaut.width / 2, astronaut.y + astronaut.height / 2, 10, 'explosion');
                }
            }

            function updateHealthBar() {
                const maxHealth = 200 + (upgrades.health.level - 1) * 50;
                const healthPercentage = clamp((astronaut.health / maxHealth) * 100, 0, 100);
                healthBarInner.style.width = `${healthPercentage}%`;
            }

            function shootProjectile() {
                if (astronaut.shootCooldown <= 0) {
                    if (input.fireMode === 'single') {
                        entities.projectiles.push({
                            x: astronaut.x + astronaut.width,
                            y: astronaut.y + astronaut.height / 2,
                            width: PIXEL_GRID / 2 * state.scale,
                            height: PIXEL_GRID / 4 * state.scale,
                            speed: 300 * state.scale,
                            id: generateUUID()
                        });
                    } else {
                        for (let i = -1; i <= 1; i++) {
                            entities.projectiles.push({
                                x: astronaut.x + astronaut.width,
                                y: astronaut.y + astronaut.height / 2,
                                width: PIXEL_GRID / 2 * state.scale,
                                height: PIXEL_GRID / 4 * state.scale,
                                speed: 300 * state.scale,
                                speedY: i * 50 * state.scale,
                                id: generateUUID()
                            });
                        }
                    }
                    astronaut.shootCooldown = 500 - (upgrades.fireRate.level - 1) * 100;
                    playSound('shoot');
                }
            }

       function generateEntity(type, currentTime) {
        // If boss is active, significantly reduce spawn rates for packets and buffs
        // and prevent other dangerous entities from spawning
        const spawnInterval = {
            packet: entities.boss ? 5000 : 1500 / (state.level + Math.min(state.combo / 10, 2)),
            asteroid: entities.boss ? Infinity : 2000 / (state.level + 1 + Math.min(state.combo / 10, 2)),
            comet: entities.boss ? Infinity : 2500 / (state.level + 1 + Math.min(state.combo / 10, 2)),
            blackHole: entities.boss ? Infinity : (state.level >= 5 ? 8000 / (state.level + 1) : Infinity), // Reduced frequency, only from level 5
            drone: entities.boss ? Infinity : 5000 / (state.level + 1),
            kamikazeDrone: entities.boss ? Infinity : 6000 / (state.level + 1),
            buff: entities.boss ? 10000 : 5000 / state.level
        };

        if (currentTime - state.spawnTimes[type] < spawnInterval[type]) return;

        switch (type) {
            case 'packet':
                if (entities.packets.length < (entities.boss ? 5 : 10)) {
                    entities.packets.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - PIXEL_GRID * state.scale),
                        width: PIXEL_GRID * state.scale,
                        height: PIXEL_GRID * state.scale,
                        speed: 50 * state.scale / state.level,
                        id: generateUUID()
                    });
                    state.spawnTimes.packet = currentTime;
                }
                break;
            case 'asteroid':
                if (entities.asteroids.length < 5 + state.level) {
                    entities.asteroids.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - 2 * PIXEL_GRID * state.scale),
                        width: 2 * PIXEL_GRID * state.scale,
                        height: 2 * PIXEL_GRID * state.scale,
                        speed: 40 * state.scale * state.level,
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.05,
                        id: generateUUID()
                    });
                    state.spawnTimes.asteroid = currentTime;
                }
                break;
            case 'comet':
                if (entities.comets.length < 3 + state.level) {
                    entities.comets.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - PIXEL_GRID * state.scale),
                        width: PIXEL_GRID * state.scale,
                        height: PIXEL_GRID * state.scale,
                        speed: 70 * state.scale * state.level,
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.07,
                        id: generateUUID()
                    });
                    state.spawnTimes.comet = currentTime;
                }
                break;
            case 'blackHole':
                if (state.level >= 5 && entities.blackHoles.length < 2 + state.level) {
                    entities.blackHoles.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - 2 * PIXEL_GRID * state.scale),
                        width: 2 * PIXEL_GRID * state.scale,
                        height: 2 * PIXEL_GRID * state.scale,
                        pullRadius: 300 * state.scale, // Increased pull radius for more danger
                        rotation: 0,
                        rotationSpeed: 0.07, // Faster rotation
                        id: generateUUID(),
                        lastDroneSpawn: currentTime,
                        damage: 75 // Increased damage on collision
                    });
                    state.spawnTimes.blackHole = currentTime;
                }
                break;
            case 'drone':
                if (entities.drones.length < 1 + Math.floor(state.level / 2)) {
                    entities.drones.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - PIXEL_GRID * state.scale),
                        width: PIXEL_GRID * state.scale,
                        height: PIXEL_GRID * state.scale,
                        speed: 60 * state.scale * state.level,
                        id: generateUUID()
                    });
                    state.spawnTimes.drone = currentTime;
                }
                break;
            case 'kamikazeDrone':
                if (entities.drones.length < 1 + Math.floor(state.level / 3)) {
                    entities.drones.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - PIXEL_GRID * state.scale),
                        width: PIXEL_GRID * state.scale,
                        height: PIXEL_GRID * state.scale,
                        speed: 100 * state.scale * state.level,
                        id: generateUUID(),
                        type: 'kamikaze',
                        chargeDelay: 2000
                    });
                    state.spawnTimes.kamikazeDrone = currentTime;
                }
                break;
            case 'buff':
                if (entities.buffs.length < (entities.boss ? 1 : 2)) {
                    const buffType = Math.random() > 0.5 ? 'speed' : 'health';
                    entities.buffs.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - PIXEL_GRID * state.scale),
                        width: PIXEL_GRID * state.scale,
                        height: PIXEL_GRID * state.scale,
                        speed: 40 * state.scale / state.level,
                        type: buffType,
                        id: generateUUID()
                    });
                    state.spawnTimes.buff = currentTime;
                }
                break;
        }
    }
       function generateBoss(currentTime) {
    if (state.score >= 100 && !entities.boss && !state.bossDefeated) {
        entities.boss = {
            x: canvas.width - 100 * state.scale,
            y: canvas.height / 2,
            width: 6 * PIXEL_GRID * state.scale,
            height: 6 * PIXEL_GRID * state.scale,
            pullRadius: 350 * state.scale,
            rotation: 0,
            rotationSpeed: 0.03,
            id: 'boss',
            spawnTime: currentTime,
            speed: 80 * state.scale,
            phaseChangeTime: currentTime,
            attackPattern: 'circle'
        };
        bossState.health = 300;
        bossState.phase = 1;
        bossState.attackCooldown = 0;
        // Clear existing dangerous entities
        entities.asteroids = [];
        entities.comets = [];
        entities.blackHoles = [];
        entities.drones = [];
    }
}
function updateBoss(deltaTime, currentTime) {
    if (!entities.boss) return;
    const boss = entities.boss;
    bossState.attackCooldown -= deltaTime * 1000;

    // Movement logic based on phase
    if (bossState.phase === 1) {
        // Phase 1: Sinusoidal movement
        boss.y += Math.sin(state.gameTime * 0.002) * 80 * state.scale * deltaTime;
        if (bossState.attackCooldown <= 0) {
            // Circular projectile barrage
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI / 6) * i;
                entities.projectiles.push({
                    x: boss.x + boss.width / 2,
                    y: boss.y + boss.height / 2,
                    width: PIXEL_GRID / 2 * state.scale,
                    height: PIXEL_GRID / 4 * state.scale,
                    speed: Math.cos(angle) * 200 * state.scale,
                    speedY: Math.sin(angle) * 200 * state.scale,
                    isEnemy: true,
                    id: generateUUID()
                });
            }
            bossState.attackCooldown = 1500;
            playSound('shoot');
        }
    } else {
        // Phase 2: Chase astronaut
        const dx = astronaut.x - boss.x;
        const dy = astronaut.y - boss.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > 0) {
            boss.x += (dx / distance) * boss.speed * deltaTime;
            boss.y += (dy / distance) * boss.speed * deltaTime;
        }
        if (bossState.attackCooldown <= 0) {
            // Targeted spread shot
            const angle = Math.atan2(astronaut.y - boss.y, astronaut.x - boss.x);
            for (let i = -1; i <= 1; i++) {
                const spreadAngle = angle + (i * Math.PI / 12);
                entities.projectiles.push({
                    x: boss.x + boss.width / 2,
                    y: boss.y + boss.height / 2,
                    width: PIXEL_GRID / 2 * state.scale,
                    height: PIXEL_GRID / 4 * state.scale,
                    speed: Math.cos(spreadAngle) * 250 * state.scale,
                    speedY: Math.sin(spreadAngle) * 250 * state.scale,
                    isEnemy: true,
                    id: generateUUID()
                });
            }
            bossState.attackCooldown = 800;
            playSound('shoot');
        }
    }

    // Phase transition
    if (bossState.health <= 150 && bossState.phase === 1) {
        bossState.phase = 2;
        boss.phaseChangeTime = currentTime;
        boss.speed *= 1.5;
        spawnParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, 20, 'explosion');
    }

    // Apply pull effect to astronaut
    const dx = boss.x + boss.width / 2 - (astronaut.x + astronaut.width / 2);
    const dy = boss.y + boss.height / 2 - (astronaut.y + astronaut.height / 2);
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance < boss.pullRadius && distance > 0) {
        const force = (boss.pullRadius - distance) / boss.pullRadius * 150 * state.scale;
        astronaut.x += (dx / distance) * force * deltaTime;
        astronaut.y += (dy / distance) * force * deltaTime;
    }

    boss.y = clamp(boss.y, 0, canvas.height - boss.height);
    boss.x = clamp(boss.x, 0, canvas.width - boss.width);
    addToGrid(boss, boss.x, boss.y, boss.width, boss.height);
}


            function updateInputState() {
                input.state.direction = { x: 0, y: 0 };
                input.state.shoot = false;
                input.state.dash = false;
                input.state.toggleFireMode = false;
                input.state.openUpgradeMenu = false;

                if (input.joystick.active) {
                    const dx = input.joystick.x - input.joystick.baseX;
                    const dy = input.joystick.y - input.joystick.baseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > JOYSTICK_DEADZONE * state.scale) {
                        const normalizedDistance = Math.min(distance, JOYSTICK_MAX_DISTANCE * state.scale);
                        input.state.direction.x = (dx / normalizedDistance) * (normalizedDistance / (JOYSTICK_MAX_DISTANCE * state.scale));
                        input.state.direction.y = (dy / normalizedDistance) * (normalizedDistance / (JOYSTICK_MAX_DISTANCE * state.scale));
                        input.lastInputType = 'joystick';
                    }
                }

                if (!input.joystick.active || (input.lastInputType === 'keyboard' && input.state.direction.x === 0 && input.state.direction.y === 0)) {
                    if (input.keys.get('ArrowUp') || input.keys.get('z') || input.keys.get('Z')) input.state.direction.y -= 1;
                    if (input.keys.get('ArrowDown') || input.keys.get('s') || input.keys.get('S')) input.state.direction.y += 1;
                    if (input.keys.get('ArrowLeft') || input.keys.get('q') || input.keys.get('Q')) input.state.direction.x -= 1;
                    if (input.keys.get('ArrowRight') || input.keys.get('d') || input.keys.get('D')) input.state.direction.x += 1;
                    if (input.keys.get(' ')) input.state.shoot = true;
                    if (input.keys.get('e') || input.keys.get('E')) input.state.dash = true;
                    if (input.keys.get('Shift')) input.state.toggleFireMode = true;
                    if (input.keys.get('u') || input.keys.get('U')) input.state.openUpgradeMenu = true;
                    if (input.state.direction.x !== 0 || input.state.direction.y !== 0) input.lastInputType = 'keyboard';
                }

                const magnitude = Math.sqrt(input.state.direction.x ** 2 + input.state.direction.y ** 2);
                if (magnitude > 1) {
                    input.state.direction.x /= magnitude;
                    input.state.direction.y /= magnitude;
                }
            }

          function updateAstronaut(deltaTime) {
    updateInputState();
    astronaut.velocity = { x: 0, y: 0 };
    astronaut.state = 'idle';

    if (input.state.shoot && !state.gameOver && state.gameStarted) {
        shootProjectile();
    }
    if (input.state.toggleFireMode) {
        input.fireMode = input.fireMode === 'single' ? 'spread' : 'single';
        input.keys.set('Shift', false);
    }
    if (input.state.dash && astronaut.dashCooldown <= 0 && !astronaut.isDashing) {
        astronaut.isDashing = true;
        astronaut.dashTime = DASH_DURATION;
        astronaut.dashCooldown = 3000 - (upgrades.dash.level - 1) * 500;
        astronaut.dashDirection = {
            x: input.state.direction.x || astronaut.dashDirection.x || 1,
            y: input.state.direction.y || astronaut.dashDirection.y || 0
        };
        const magnitude = Math.sqrt(astronaut.dashDirection.x ** 2 + astronaut.dashDirection.y ** 2);
        if (magnitude > 0) {
            astronaut.dashDirection.x /= magnitude;
            astronaut.dashDirection.y /= magnitude;
        }
        input.keys.set('e', false);
        input.keys.set('E', false);
    }

    if (astronaut.isDashing) {
        astronaut.velocity.x = astronaut.dashDirection.x * DASH_SPEED * state.scale;
        astronaut.velocity.y = astronaut.dashDirection.y * DASH_SPEED * state.scale;
        astronaut.dashTime -= deltaTime * 1000;
        if (astronaut.dashTime <= 0) {
            astronaut.isDashing = false;
        }
    } else if (!ui.showUpgradeMenu) {
        astronaut.velocity.x = input.state.direction.x * astronaut.speed;
        astronaut.velocity.y = input.state.direction.y * astronaut.speed;
        if (input.state.direction.x !== 0 || input.state.direction.y !== 0) {
            astronaut.state = 'moving';
        }
    }

    astronaut.x += astronaut.velocity.x * deltaTime;
    astronaut.y += astronaut.velocity.y * deltaTime;

    astronaut.x = clamp(astronaut.x, 0, canvas.width - astronaut.width);
    astronaut.y = clamp(astronaut.y, 0, canvas.height - astronaut.height);

    astronaut.shootCooldown -= deltaTime * 1000;
    astronaut.invincibility -= deltaTime * 1000;
    astronaut.dashCooldown -= deltaTime * 1000;

    if (astronaut.health <= 0 && !state.gameOver) {
        state.gameOver = true;
        state.leaderboard.push(state.score);
        state.leaderboard.sort((a, b) => b - a);
        state.leaderboard = state.leaderboard.slice(0, 5);
        localStorage.setItem('leaderboard', JSON.stringify(state.leaderboard));
        if (state.score > state.highScore) {
            state.highScore = state.score;
            localStorage.setItem('highScore', state.highScore);
        }
        stopBackgroundMusic();
    }
}

    function applyBlackHolePull(entity, blackHole, deltaTime) {
        // Only apply pull to the astronaut
        if (entity !== astronaut) return;
        const dx = blackHole.x + blackHole.width / 2 - (entity.x + entity.width / 2);
        const dy = blackHole.y + blackHole.height / 2 - (entity.y + entity.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < blackHole.pullRadius && distance > 0) {
            const force = (blackHole.pullRadius - distance) / blackHole.pullRadius * 100 * state.scale;
            entity.x += (dx / distance) * force * deltaTime;
            entity.y += (dy / distance) * force * deltaTime;
        }
    }


 function updateEntities(deltaTime) {
    clearGrid();

    entities.packets.forEach(packet => {
        packet.x -= packet.speed * deltaTime;
        addToGrid(packet, packet.x, packet.y, packet.width, packet.height);
    });
    entities.packets = entities.packets.filter(p => p.x + p.width > 0);

    entities.asteroids.forEach(asteroid => {
        asteroid.x -= asteroid.speed * deltaTime;
        addToGrid(asteroid, asteroid.x, asteroid.y, asteroid.width, asteroid.height);
    });
    entities.asteroids = entities.asteroids.filter(a => a.x + a.width > 0);

    entities.comets.forEach(comet => {
        comet.x -= comet.speed * deltaTime;
        addToGrid(comet, comet.x, comet.y, comet.width, comet.height);
    });
    entities.comets = entities.comets.filter(c => c.x + c.width > 0);

    entities.blackHoles.forEach(blackHole => {
        blackHole.x -= 10 * state.scale * deltaTime;
        addToGrid(blackHole, blackHole.x, blackHole.y, blackHole.width, blackHole.height);
    });
    entities.blackHoles = entities.blackHoles.filter(b => b.x + b.width > 0);

    entities.buffs.forEach(buff => {
        buff.x -= buff.speed * deltaTime;
        addToGrid(buff, buff.x, buff.y, buff.width, buff.height);
    });
    entities.buffs = entities.buffs.filter(b => b.x + b.width > 0);

    entities.drones.forEach(drone => {
        if (drone.type === 'kamikaze') {
            drone.chargeDelay -= deltaTime * 1000;
            if (drone.chargeDelay <= 0) {
                const dx = astronaut.x - drone.x;
                const dy = astronaut.y - drone.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    drone.x += (dx / distance) * drone.speed * deltaTime;
                    drone.y += (dy / distance) * drone.speed * deltaTime;
                }
            } else {
                drone.x -= drone.speed * deltaTime;
            }
        } else {
            drone.x -= drone.speed * deltaTime;
        }
        addToGrid(drone, drone.x, drone.y, drone.width, drone.height);
    });
    entities.drones = entities.drones.filter(d => d.x + d.width > 0);

    entities.projectiles.forEach(projectile => {
        projectile.x += projectile.speed * deltaTime;
        if (projectile.speedY) {
            projectile.y += projectile.speedY * deltaTime;
        }
        addToGrid(projectile, projectile.x, projectile.y, projectile.width, projectile.height);
    });
    entities.projectiles = entities.projectiles.filter(p => p.x < canvas.width && p.x + p.width > 0);

    if (entities.boss) {
        const boss = entities.boss;
        if (bossState.phase === 1) {
            boss.y += Math.sin(state.gameTime * 0.001) * 50 * state.scale * deltaTime;
        } else {
            const dx = astronaut.x - boss.x;
            const dy = astronaut.y - boss.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0) {
                boss.x += (dx / distance) * boss.speed * deltaTime;
                boss.y += (dy / distance) * boss.speed * deltaTime;
            }
        }
        boss.y = clamp(boss.y, 0, canvas.height - boss.height);
        addToGrid(boss, boss.x, boss.y, boss.width, boss.height);

        if (state.gameTime - boss.phaseChangeTime > 10000) {
            bossState.phase = bossState.phase === 1 ? 2 : 1;
            boss.phaseChangeTime = state.gameTime;
        }
    }

    entities.blackHoles.forEach(blackHole => applyBlackHolePull(astronaut, blackHole, deltaTime));
}


 function checkCollisions() {
    collidedThisFrame.clear();
    const nearbyEntities = getNearbyEntities(astronaut.x, astronaut.y, astronaut.width, astronaut.height);

    nearbyEntities.forEach(entity => {
        if (checkCollision(astronaut, entity) && !collidedThisFrame.has(entity.id)) {
            collidedThisFrame.add(entity.id);
            if (entity.speed !== undefined && entities.packets.includes(entity)) {
                state.score += 1 + Math.floor(state.combo / 5);
                state.combo++;
                entities.packets = entities.packets.filter(p => p !== entity);
                playSound('collect');
                spawnParticles(entity.x + entity.width / 2, entity.y + entity.height / 2, 5, 'collect');
                clearTimeout(ui.comboTimeout);
                ui.comboTimeout = setTimeout(() => state.combo = 0, 3000);
                if (state.score >= 100 && !entities.boss) {
                    state.achievements.collector = true;
                    localStorage.setItem('achievements', JSON.stringify(state.achievements));
                }
            } else if (entities.buffs.includes(entity)) {
                if (entity.type === 'speed') {
                    astronaut.speed = astronaut.baseSpeed * (1 + 0.2 * upgrades.speed.level);
                    ui.speedBoostActive = true;
                    clearTimeout(ui.speedBoostTimeout);
                    ui.speedBoostTimeout = setTimeout(() => {
                        astronaut.speed = astronaut.baseSpeed;
                        ui.speedBoostActive = false;
                    }, 5000);
                } else if (entity.type === 'health') {
                    astronaut.health = Math.min(astronaut.health + 50, 200 + (upgrades.health.level - 1) * 50);
                    updateHealthBar();
                }
                entities.buffs = entities.buffs.filter(b => b !== entity);
                spawnParticles(entity.x + entity.width / 2, entity.y + entity.height / 2, 5, 'collect');
            } else if (entities.asteroids.includes(entity) || entities.comets.includes(entity) || entities.drones.includes(entity)) {
                takeDamage(entities.comets.includes(entity) ? 50 : entities.drones.includes(entity) && entity.type === 'kamikaze' ? 75 : 25);
                if (entities.asteroids.includes(entity)) {
                    entities.asteroids = entities.asteroids.filter(a => a !== entity);
                } else if (entities.comets.includes(entity)) {
                    entities.comets = entities.comets.filter(c => c !== entity);
                } else {
                    entities.drones = entities.drones.filter(d => d !== entity);
                }
                spawnParticles(entity.x + entity.width / 2, entity.y + entity.height / 2, 10, 'explosion');
            } else if (entities.blackHoles.includes(entity)) {
                takeDamage(entity.damage || 75);
                spawnParticles(astronaut.x + astronaut.width / 2, astronaut.y + astronaut.height / 2, 20, 'explosion');
                entities.blackHoles = entities.blackHoles.filter(b => b !== entity);
                respawnAstronaut();
            } else if (entities.boss === entity) {
                collidedThisFrame.add(entity.id);
                takeDamage(75);
                spawnParticles(astronaut.x + astronaut.width / 2, astronaut.y + astronaut.height / 2, 15, 'explosion');
                respawnAstronaut();
            }
        }
    });

    entities.projectiles.forEach(projectile => {
        if (!projectile.isEnemy) {
            const nearby = getNearbyEntities(projectile.x, projectile.y, projectile.width, projectile.height);
            nearby.forEach(entity => {
                if ((entities.asteroids.includes(entity) || entities.comets.includes(entity) || entities.drones.includes(entity) || entities.boss === entity) && checkCollision(projectile, entity) && !collidedThisFrame.has(projectile.id)) {
                    collidedThisFrame.add(projectile.id);
                    if (entities.asteroids.includes(entity)) {
                        entities.asteroids = entities.asteroids.filter(a => a !== entity);
                        state.enemiesDestroyed++;
                    } else if (entities.comets.includes(entity)) {
                        entities.comets = entities.comets.filter(c => c !== entity);
                        state.enemiesDestroyed++;
                    } else if (entities.drones.includes(entity)) {
                        entities.drones = entities.drones.filter(d => d !== entity);
                        state.enemiesDestroyed++;
                    } else if (entities.boss === entity) {
    bossState.health -= 5;
    if (bossState.health <= 0) {
        entities.boss = null;
        state.bossDefeated = true; // Prevent respawn
        state.score += 100;
        state.enemiesDestroyed += 10;
        spawnParticles(entity.x + entity.width / 2, entity.y + entity.height / 2, 50, 'explosion');
    }
}
                    entities.projectiles = entities.projectiles.filter(p => p !== projectile);
                    spawnParticles(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2, 5, 'explosion');
                }
            });
        } else {
            if (checkCollision(projectile, astronaut) && !collidedThisFrame.has(projectile.id)) {
                collidedThisFrame.add(projectile.id);
                takeDamage(25);
                entities.projectiles = entities.projectiles.filter(p => p !== projectile);
                spawnParticles(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2, 5, 'explosion');
            }
        }
    });

    if (state.enemiesDestroyed >= 50 && !state.achievements.sharpshooter) {
        state.achievements.sharpshooter = true;
        localStorage.setItem('achievements', JSON.stringify(state.achievements));
    }
}
     function respawnAstronaut() {
        // Find a safe respawn location
        let safe = false;
        let newX, newY;
        while (!safe) {
            newX = Math.random() * (canvas.width - astronaut.width);
            newY = Math.random() * (canvas.height - astronaut.height);
            safe = true;
            // Check if the new position is too close to any black hole
            for (let blackHole of entities.blackHoles) {
                const dx = blackHole.x + blackHole.width / 2 - (newX + astronaut.width / 2);
                const dy = blackHole.y + blackHole.height / 2 - (newY + astronaut.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < blackHole.pullRadius) {
                    safe = false;
                    break;
                }
            }
        }
        // Respawn the astronaut
        astronaut.x = newX;
        astronaut.y = newY;
        astronaut.velocity = { x: 0, y: 0 };
        astronaut.invincibility = 2000; // 2 seconds of invincibility
        astronaut.isDashing = false;
        astronaut.dashTime = 0;
        playSound('damage');
        ui.shakeTime = 300;
        ui.shakeIntensity = 5 * state.scale;
    }

 function updateGame(deltaTime) {
        if (!state.gameStarted || state.gameOver || ui.showUpgradeMenu) return;

        state.gameTime += deltaTime * 1000;
        state.level = Math.min(Math.floor(state.score / 20) + 1, 10);

        updateAstronaut(deltaTime);
        updateEntities(deltaTime);
        updateParticles(deltaTime);

        if (!entities.boss) {
            generateEntity('packet', state.gameTime);
            generateEntity('asteroid', state.gameTime);
            generateEntity('comet', state.gameTime);
            if (state.level >= 5) {
                generateEntity('blackHole', state.gameTime);
            }
            generateEntity('drone', state.gameTime);
            generateEntity('kamikazeDrone', state.gameTime);
            generateEntity('buff', state.gameTime);
        } else {
            // Only spawn packets and buffs during boss fight
            generateEntity('packet', state.gameTime);
            generateEntity('buff', state.gameTime);
        }
        generateBoss(state.gameTime);

        checkCollisions();

        if (ui.shakeTime > 0) {
            ui.shakeTime -= deltaTime * 1000;
            ui.shakeIntensity = Math.max(ui.shakeIntensity * 0.9, 0);
        }

        scoreLevelDisplay.textContent = `Score: ${state.score} | Level: ${state.level} | High Score: ${state.highScore} | Combo: ${state.combo}`;
    }

function render() {
    ctx.save();
    if (ui.shakeTime > 0) {
        ctx.translate(
            (Math.random() - 0.5) * ui.shakeIntensity,
            (Math.random() - 0.5) * ui.shakeIntensity
        );
    }

    if (!state.gameStarted) {
        drawIntroScreen();
    } else {
        drawBackgrounds(FRAME_TIME / 1000);
        drawParticles();
        drawAstronaut();
        entities.packets.forEach(drawPacket);
        entities.asteroids.forEach(drawAsteroid);
        entities.comets.forEach(drawComet);
        entities.blackHoles.forEach(drawBlackHole);
        entities.buffs.forEach(drawBuff);
        entities.drones.forEach(drawDrone);
        entities.projectiles.forEach(drawProjectile);
        drawBoss();
        drawUpgradeMenu();
        drawJoystick();

        if (state.gameOver) {
            ctx.fillStyle = 'rgba(10, 28, 43, 0.95)';
            ctx.fillRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 2);
            ctx.strokeStyle = 'rgba(163, 223, 255, 0.6)';
            ctx.lineWidth = 4 * state.scale;
            ctx.strokeRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 2);
            ctx.fillStyle = 'rgba(163, 223, 255, 0.2)';
            ctx.fillRect(canvas.width / 4, canvas.height / 4, canvas.width / 2, canvas.height / 2);
            ctx.fillStyle = palette.accent;
            ctx.font = `24px 'Press Start 2P', monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 80 * state.scale);
            ctx.fillStyle = palette.secondary;
            ctx.font = `16px 'Press Start 2P', monospace`;
            ctx.fillText(`Score: ${state.score}`, canvas.width / 2, canvas.height / 2 - 40 * state.scale);
            ctx.fillText(`High Score: ${state.highScore}`, canvas.width / 2, canvas.height / 2 - 20 * state.scale);
            ctx.fillText('Achievements:', canvas.width / 2, canvas.height / 2);
            ctx.font = `12px 'Press Start 2P', monospace`;
            ctx.fillText(state.achievements.collector ? 'Collector: Earned' : 'Collector: Collect 100 packets', canvas.width / 2, canvas.height / 2 + 20 * state.scale);
            ctx.fillText(state.achievements.survivor ? 'Survivor: Earned' : 'Survivor: Survive 5 minutes', canvas.width / 2, canvas.height / 2 + 40 * state.scale);
            ctx.fillText(state.achievements.sharpshooter ? 'Sharpshooter: Earned' : 'Sharpshooter: Destroy 50 enemies', canvas.width / 2, canvas.height / 2 + 60 * state.scale);
            drawReplayButton();
        }
    }

    ctx.restore();
}

function gameLoop(currentTime) {
    const deltaTime = Math.min((currentTime - lastTime) / 1000, FRAME_TIME / 1000);
    lastTime = currentTime;

    frameCount++;
    if (currentTime - lastFpsTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFpsTime = currentTime;
    }

    updateGame(deltaTime);
    render();

    requestAnimationFrame(gameLoop);
}

// Event Handlers
function handleUpgradeInput(event) {
    if (!ui.showUpgradeMenu || state.gameOver || !state.gameStarted) return;
    event.preventDefault();
    let upgrade = null;
    switch (event.key) {
        case '1': upgrade = upgrades.speed; break;
        case '2': upgrade = upgrades.health; break;
        case '3': upgrade = upgrades.fireRate; break;
        case '4': upgrade = upgrades.dash; break;
    }
    if (upgrade && upgrade.level < upgrade.maxLevel && state.score >= upgrade.cost) {
        state.score -= upgrade.cost;
        upgrade.level++;
        upgrade.cost = Math.floor(upgrade.cost * 1.5);
        if (upgrade === upgrades.speed) {
            astronaut.baseSpeed = 200 * state.scale * (1 + 0.2 * upgrade.level);
            astronaut.speed = ui.speedBoostActive ? astronaut.baseSpeed * (1 + 0.2 * upgrades.speed.level) : astronaut.baseSpeed;
        } else if (upgrade === upgrades.health) {
            astronaut.health = Math.min(astronaut.health + 50, 200 + (upgrade.level - 1) * 50);
            updateHealthBar();
        }
    }
}

function initEventListeners() {
    const debouncedResize = debounce(resizeCanvas, 100);
    window.addEventListener('resize', debouncedResize);
    window.addEventListener('orientationchange', debouncedResize);

    window.addEventListener('keydown', event => {
        input.keys.set(event.key, true);
        if (!state.gameStarted && event.key === ' ' && !state.gameOver) {
            state.gameStarted = true;
            astronaut.health = 200;
            state.score = 0;
            state.combo = 0;
            state.level = 1;
            state.enemiesDestroyed = 0;
            entities.packets = [];
            entities.asteroids = [];
            entities.comets = [];
            entities.blackHoles = [];
            entities.buffs = [];
            entities.drones = [];
            entities.projectiles = [];
            entities.boss = null;
            astronaut.x = canvas.width / 4;
            astronaut.y = canvas.height / 2;
            updateHealthBar();
            if (soundEnabled) startBackgroundMusic();
        }
        if ((event.key === 'u' || event.key === 'U') && !state.gameOver && state.gameStarted && !input.uKeyPressed) {
            ui.showUpgradeMenu = !ui.showUpgradeMenu; // Toggle the menu
            input.uKeyPressed = true; // Prevent further toggles until key release
        }
        if (ui.showUpgradeMenu && ['1', '2', '3', '4'].includes(event.key)) {
            handleUpgradeInput(event);
        }
    });

    window.addEventListener('keyup', event => {
        input.keys.set(event.key, false);
        if (event.key === 'u' || event.key === 'U') {
            input.uKeyPressed = false; // Allow toggling again after key release
        }
    });

    window.addEventListener('keyup', event => {
        input.keys.set(event.key, false);
    });

    function getTouchPos(event) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (event.touches[0].clientX - rect.left) * window.devicePixelRatio,
            y: (event.touches[0].clientY - rect.top) * window.devicePixelRatio
        };
    }

    canvas.addEventListener('touchstart', event => {
        event.preventDefault();
        const pos = getTouchPos(event);
        input.joystick.active = true;
        input.joystick.baseX = pos.x;
        input.joystick.baseY = pos.y;
        input.joystick.x = pos.x;
        input.joystick.y = pos.y;
    });

    canvas.addEventListener('touchmove', event => {
        event.preventDefault();
        if (input.joystick.active) {
            const pos = getTouchPos(event);
            const dx = pos.x - input.joystick.baseX;
            const dy = pos.y - input.joystick.baseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = JOYSTICK_MAX_DISTANCE * state.scale;
            if (distance > maxDistance) {
                input.joystick.x = input.joystick.baseX + (dx / distance) * maxDistance;
                input.joystick.y = input.joystick.baseY + (dy / distance) * maxDistance;
            } else {
                input.joystick.x = pos.x;
                input.joystick.y = pos.y;
            }
        }
    });

    canvas.addEventListener('touchend', event => {
        event.preventDefault();
        input.joystick.active = false;
        if (state.gameOver) {
            const pos = getTouchPos(event);
            const button = drawReplayButton();
            if (pos.x >= button.x && pos.x <= button.x + button.width &&
                pos.y >= button.y && pos.y <= button.y + button.height) {
                state.gameOver = false;
                state.gameStarted = false;
                astronaut.health = 200;
                state.score = 0;
                state.combo = 0;
                state.level = 1;
                state.enemiesDestroyed = 0;
                entities.packets = [];
                entities.asteroids = [];
                entities.comets = [];
                entities.blackHoles = [];
                entities.buffs = [];
                entities.drones = [];
                entities.projectiles = [];
                entities.boss = null;
                astronaut.x = canvas.width / 4;
                astronaut.y = canvas.height / 2;
                updateHealthBar();
            }
        }
    });

    canvas.addEventListener('mousedown', event => {
        if (state.gameOver) {
            const rect = canvas.getBoundingClientRect();
            const pos = {
                x: (event.clientX - rect.left) * window.devicePixelRatio,
                y: (event.clientY - rect.top) * window.devicePixelRatio
            };
            const button = drawReplayButton();
            if (pos.x >= button.x && pos.x <= button.x + button.width &&
                pos.y >= button.y && pos.y <= button.y + button.height) {
                state.gameOver = false;
                state.gameStarted = false;
                astronaut.health = 200;
                state.score = 0;
                state.combo = 0;
                state.level = 1;
                state.enemiesDestroyed = 0;
                entities.packets = [];
                entities.asteroids = [];
                entities.comets = [];
                entities.blackHoles = [];
                entities.buffs = [];
                entities.drones = [];
                entities.projectiles = [];
                entities.boss = null;
                astronaut.x = canvas.width / 4;
                astronaut.y = canvas.height / 2;
                updateHealthBar();
            }
        }
    });
}

// Initialization
function init() {
    resizeCanvas();
    initAudio();
    initEventListeners();
    requestAnimationFrame(gameLoop);
}

init();
})();
    </script>
{% endblock %}
{% block javascripts %}
    {{ parent() }}
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const header = document.querySelector('header');
            const footer = document.querySelector('footer');
            if (header) header.classList.add('hidden');
            if (footer) footer.classList.add('hidden');
        });
    </script>
{% endblock %}